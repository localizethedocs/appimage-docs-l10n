# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018-2022, The AppImage project
# This file is distributed under the same license as the AppImage package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AppImage master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-04 12:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/reference/best-practices.rst:2
msgid "Best practices"
msgstr "最佳實務"

#: ../../../source/reference/best-practices.rst:4
msgid ""
"This section contains some best practices and recommendations how to "
"generally design and write software so that it can be easily put into "
"AppImages."
msgstr ""
"本節包含一些最佳實務與建議，說明如何一般性地設計與撰寫軟體，以便能輕鬆打包成 "
"AppImage。"

#: ../../../source/reference/best-practices.rst:10
msgid "Contents"
msgstr "目次"

#: ../../../source/reference/best-practices.rst:13
msgid "General Recommendations"
msgstr "一般建議"

#: ../../../source/reference/best-practices.rst:15
msgid ""
"It is crucial to understand that AppImage is merely a format for "
"distributing applications. In this regard, AppImage is like a :code:`.zip` "
"file or an :code:`.iso` file. It does not define how to compile "
"applications. It it is also not a build system."
msgstr ""
"務必理解 AppImage 只是用來散布應用程式的格式。就這點而言，AppImage 類似於 :"
"code:`.zip` 或 :code:`.iso` 檔案。它並不定義如何編譯應用程式，也不是建置系"
"統。"

#: ../../../source/reference/best-practices.rst:17
msgid ""
"It is crucial to put binaries inside AppImages that are compatible with a "
"variety of target systems. What goes into the AppImage is called the "
"“payload”, or the “ingredients”. Producing the payload requires some "
"thought, as you want your AppImage to run on as many targets systems as "
"possible."
msgstr ""
"務必在 AppImage 中放入能與多種目標系統相容的二進位檔。放入 AppImage 的內容稱"
"為「payload」或「ingredients」。製作 payload 需要一些考量，因為您希望 "
"AppImage 能在越多目標系統上執行越好。"

#: ../../../source/reference/best-practices.rst:19
msgid ""
"For an AppImage to run on most systems, the following conditions need to be "
"met:"
msgstr "要讓 AppImage 在大多數系統上執行，需符合以下條件："

#: ../../../source/reference/best-practices.rst:21
msgid ""
":ref:`Binaries must not use compiled-in absolute paths <ref-binaries-no-abs-"
"paths>` (and if they do, they need to be binary-patched)"
msgstr ""
":ref:`二進位檔不得使用編譯時寫死的絕對路徑 <ref-binaries-no-abs-paths>`（若有"
"使用，需進行二進位修補）"

#: ../../../source/reference/best-practices.rst:22
msgid ""
"The AppImage needs to include all libraries and other dependencies that are "
"not part of all of the base systems that the AppImage is intended to run on."
msgstr ""
"AppImage 必須包含所有不一定存在於其目標基礎系統中的函式庫與其他相依項目。"

#: ../../../source/reference/best-practices.rst:23
msgid ""
"The binaries contained in the AppImage need to be compiled on a system not "
"newer than the oldest base system that the AppImage is intended to run on."
msgstr ""
"AppImage 內的二進位檔必須在不新於其預計支援的最舊基礎系統的環境中編譯。"

#: ../../../source/reference/best-practices.rst:24
msgid ""
"The AppImage should actually be tested on the base systems that it is "
"intended to run on."
msgstr "AppImage 應實際在其預計支援的基礎系統上測試。"

#: ../../../source/reference/best-practices.rst:29
msgid "Binaries must not use compiled-in absolute paths"
msgstr "二進位檔不得使用編譯時寫死的絕對路徑"

#: ../../../source/reference/best-practices.rst:31
msgid ""
"Since an AppImage is mounted at a different location in the filesystem every "
"time it is run, it is crucial not to use compiled in absolute paths. For "
"example, if the application accesses a resource such as an image, it should "
"do so from a location relative to the main executable. Unfortunately, many "
"applications have absolute paths compiled in (:code:`$PREFIX`, most "
"commonly :code:`/usr`) at compile time."
msgstr ""
"由於 AppImage 每次執行時都會掛載到檔案系統中的不同位置，因此絕對不能使用編譯"
"時寫死的絕對路徑。例如，若應用程式要存取影像等資源，應該使用相對於主執行檔的"
"位置。不幸的是，許多應用程式在編譯時就寫死了絕對路徑（:code:`$PREFIX`，最常見"
"為 :code:`/usr`）。"

#: ../../../source/reference/best-practices.rst:37
msgid "Open source applications"
msgstr "開放原始碼應用程式"

#: ../../../source/reference/best-practices.rst:39
msgid ""
"Wherever possible you should change the Source Code of the application in "
"order not to use absolute paths. There are several ways to do this. The "
"canonical way on Linux is to resolve ``proc/self/exe`` to get the path to "
"the main executable and construct a relative path from there. As a result, "
"it should work both in normal installations and in relocatable installations "
"such as AppImages."
msgstr ""
"在可行的情況下，應修改應用程式原始碼以避免使用絕對路徑。有多種做法，其中在 "
"Linux 上的典型方式是解析 ``proc/self/exe`` 取得主執行檔路徑，再由此建立相對路"
"徑。如此可同時在一般安裝與可搬移安裝（如 AppImage）中正常運作。"

#: ../../../source/reference/best-practices.rst:41
msgid ""
"There are libraries which make this easier, for example `BinReloc`_. Also "
"see `Resourceful`_, a project to study of cross-platform techniques for "
"building applications and libraries that use resource files (e.g. icons, "
"configuration, data)."
msgstr ""
"有些函式庫可簡化此流程，例如 `BinReloc`_。也可參考 `Resourceful`_，該專案研究"
"跨平台技術，用於建置會使用資源檔（如圖示、設定、資料）的應用程式與函式庫。"

#: ../../../source/reference/best-practices.rst:43
msgid ""
"Some application frameworks such as Qt have this functionality built-in, for "
"example in :code:`QString QCoreApplication::applicationDirPath()` (`see "
"documentation`_), and construct a *relative* path to :code:`../share/kaidan/"
"images/` from there."
msgstr ""
"某些應用程式框架（如 Qt）已內建此功能，例如 :code:`QString QCoreApplication::"
"applicationDirPath()`（`參見文件`_），並由此建立指向 :code:`../share/kaidan/"
"images/` 的 *相對* 路徑。"

#: ../../../source/reference/best-practices.rst:47
msgid ""
"For an example, see: https://github.com/KaidanIM/Kaidan/commit/"
"da38011b55a1aa5d17764647ecd699deb4be437f"
msgstr ""
"範例請見：https://github.com/KaidanIM/Kaidan/commit/"
"da38011b55a1aa5d17764647ecd699deb4be437f"

#: ../../../source/reference/best-practices.rst:51
msgid ""
":code:`QStandardPaths::standardLocations(QStandardPaths::AppDataLocation)` "
"**does not work reliably.**"
msgstr ""
":code:`QStandardPaths::standardLocations(QStandardPaths::AppDataLocation)` **"
"無法可靠運作。**"

#: ../../../source/reference/best-practices.rst:53
msgid ""
"According to the `Qt documentation`_, this resolves to :code:`~/.local/share/"
"<APPNAME>`, :code:`/usr/local/share/<APPNAME>`, :code:`/usr/share/"
"<APPNAME>`, but clearly :code:`/usr` is not where these things are located "
"in an AppImage."
msgstr ""
"依 `Qt 文件`_，其會解析為 :code:`~/.local/share/<APPNAME>`、:code:`/usr/"
"local/share/<APPNAME>`、:code:`/usr/share/<APPNAME>`，但很明顯 :code:`/usr` "
"並不是 AppImage 中這些內容所在的位置。"

#: ../../../source/reference/best-practices.rst:64
msgid "Closed source applications with compiled-in absolute paths"
msgstr "含有編譯時寫死絕對路徑的閉源應用程式"

#: ../../../source/reference/best-practices.rst:66
msgid ""
"In case it is not possible to change the source code of the application, for "
"example because it is a closed source application, you could binary patch "
"the executable."
msgstr ""
"若無法更改應用程式原始碼（例如閉源應用程式），可以對可執行檔進行二進位修補。"

#: ../../../source/reference/best-practices.rst:68
msgid ""
"The trick is to search for :code:`/usr` in the binary and replace it by the "
"same length string :code:`././` which means “here”. This can be done by "
"using the following command::"
msgstr ""
"技巧是在二進位檔中搜尋 :code:`/usr`，並將其替換為等長字串 :code:`././`（意即"
"「這裡」）。可用以下命令執行："

#: ../../../source/reference/best-practices.rst:70
msgid "find usr/ -type f -executable -exec sed -i -e \"s|/usr|././|g\" {} \\;"
msgstr ""

#: ../../../source/reference/best-practices.rst:72
msgid ""
"This command is also available as part of the bash function collection at "
"`AppImage/pkg2appimage/functions.sh#L79`_. For the binary-patched "
"application to work, you need to change to the :code:`usr/` directory inside "
"the application directory before you launch the application."
msgstr ""
"此命令也可在 `AppImage/pkg2appimage/functions.sh#L79`_ 的 bash 函式集合中找"
"到。要讓二進位修補後的應用程式運作，啟動前需切換到應用程式目錄內的 :code:"
"`usr/` 目錄。"

#: ../../../source/reference/best-practices.rst:80
msgid "Binaries compiled on old enough base system"
msgstr "在足夠舊的基礎系統上編譯二進位檔"

#: ../../../source/reference/best-practices.rst:82
msgid ""
"The ingredients used in your AppImage should not be built on a more recent "
"base system than the oldest base system your AppImage is intended to run on."
msgstr ""
"AppImage 使用的 ingredients 不應在比其預計支援的最舊基礎系統還新的系統上建"
"置。"

#: ../../../source/reference/best-practices.rst:84
msgid ""
"Some core libraries, such as glibc, tend to break compatibility with older "
"base systems quite frequently, which means that binaries will run on newer, "
"but not on older base systems than the one the binaries were compiled on."
msgstr ""
"某些核心函式庫（如 glibc）常會破壞與舊版基礎系統的相容性，這代表二進位檔能在"
"較新的系統上執行，但無法在比其編譯環境更舊的系統上執行。"

#: ../../../source/reference/best-practices.rst:86
msgid "If you run into errors like this::"
msgstr "若您遇到如下錯誤："

#: ../../../source/reference/best-practices.rst:88
msgid ""
"failed to initialize: /lib/tls/i686/cmov/libc.so.6: version `GLIBC_2.11' not "
"found"
msgstr ""

#: ../../../source/reference/best-practices.rst:90
msgid ""
"then the binary is compiled on a newer system than the one you are trying to "
"run it on. You should use a binary that has been compiled on an older "
"system. Unfortunately, the complication is that distributions usually "
"compile the latest versions of applications only on the latest systems, "
"which means that you will have a hard time finding binaries of bleeding-edge "
"software that runs on older systems. A way around this is to compile "
"dependencies yourself on a not too recent base system, and/or to use "
"LibcWrapGenerator_ or glibc_version_header_ or bingcc_."
msgstr ""
"這表示該二進位檔是在比您嘗試執行它的系統更新的系統上編譯的。您應使用在較舊系"
"統上編譯的二進位檔。不幸的是，多數散布版通常只在最新系統上編譯最新版應用程"
"式，因此您很難找到能在舊系統上執行的前沿軟體二進位檔。其中一種做法是自己在較"
"舊的基礎系統上編譯相依項目，或使用 LibcWrapGenerator_、glibc_version_header_ "
"或 bingcc_。"

#: ../../../source/reference/best-practices.rst:92
msgid ""
"When producing AppImages for the Subsurface project, we have had very good "
"results by using **CentOS 7**, which is the oldest still-supported Linux "
"distribution at the time of writing. This distribution is not too recent. "
"However, there are still the most recent Qt and modern compilers available "
"in the EPEL_ and devtools-2_ repositories (the community equivalent of the "
"Red Hat Developer Toolset 2). Binaries built on this distribution run on "
"nearly any distribution, including **Debian oldstable**."
msgstr ""
"在為 Subsurface 專案製作 AppImage 時，我們使用 **CentOS 7** 得到非常好的結"
"果。這是撰寫本文時仍受支援的最舊 Linux 散布版，且不算太新。不過在 EPEL_ 與 "
"devtools-2_ 儲存庫（社群版的 Red Hat Developer Toolset 2）中仍有最新的 Qt 與"
"現代編譯器。在此散布版上編譯出的二進位檔幾乎可在任何散布版上執行，包括 "
"**Debian oldstable**。"

#: ../../../source/reference/best-practices.rst:94
msgid ""
"Be sure to check https://github.com/AppImage/pkg2appimage, this is how I "
"build and host my AppImages and the build systems to produce them in the "
"cloud using travis-ci, docker, docker-hub, and bintray. Especially check the "
"recipes for Subsurface and Scribus."
msgstr ""
"務必查看 https://github.com/AppImage/pkg2appimage，這是我用來建置並託管 "
"AppImage 的方式，以及在雲端使用 travis-ci、docker、docker-hub 與 bintray 產出"
"它們的建置系統。特別請查看 Subsurface 與 Scribus 的 recipes。"

#: ../../../source/reference/best-practices.rst:96
msgid ""
"See https://github.com/AppImage/AppImageKit/wiki/Docker-Hub-Travis-CI-"
"Workflow for a description on how to set up a workflow involving your GitHub "
"repository, Docker Hub, and Travis CI for a fully automated continuous build "
"workflow."
msgstr ""
"請參閱 https://github.com/AppImage/AppImageKit/wiki/Docker-Hub-Travis-CI-"
"Workflow，了解如何建立包含 GitHub 儲存庫、Docker Hub 與 Travis CI 的全自動持"
"續建置流程。"

#: ../../../source/reference/best-practices.rst:98
msgid ""
"You could also consider to link some exotic libraries statically. Yes, even "
"Debian does that: https://wiki.debian.org/Lintian"
msgstr ""
"您也可以考慮將某些較特殊的函式庫以靜態方式連結。是的，連 Debian 都這麼做："
"https://wiki.debian.org/Lintian"

#: ../../../source/reference/best-practices.rst:109
msgid "This concept is also described in :ref:`build-on-old-systems`."
msgstr "此概念也在 :ref:`build-on-old-systems` 中說明。"

#: ../../../source/reference/best-practices.rst:115
msgid "libstdc++.so.6"
msgstr ""

#: ../../../source/reference/best-practices.rst:118
msgid ""
"**As a general rule of thumb, please use no libstdc++.so.6 newer than the "
"one that comes with the oldest distribution that you still want to support, "
"i.e., the oldest still-supported LTS version of Ubuntu**."
msgstr ""
"**一般經驗法則是：請使用不新於您仍想支援的最舊散布版所隨附的 libstdc++.so.6，"
"亦即仍受支援的最舊 Ubuntu LTS 版本。**"
